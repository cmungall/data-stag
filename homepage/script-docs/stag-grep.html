<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>stag-grep</title>
<link rev="made" href="mailto:feedback@suse.de" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#usage">USAGE</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#arguments">ARGUMENTS</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>stag-grep.pl - filters a stag file (xml, itext, sxpr) for nodes of interest</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  stag-grep.pl person -q name=fred file1.xml</pre>
<pre>
  stag-grep.pl person 'sub {shift-&gt;get_name =~ /^A*/}' file1.xml</pre>
<pre>
  stag-grep.pl -p My::Foo -w sxpr record 'sub{..}' file2</pre>
<p>
</p>
<hr />
<h1><a name="usage">USAGE</a></h1>
<pre>
  stag-grep.pl [-p|parser PARSER] [-w|writer WRITER] NODE -q tag=val FILE</pre>
<pre>
  stag-grep.pl [-p|parser PARSER] [-w|writer WRITER] NODE SUB FILE</pre>
<pre>
  stag-grep.pl [-p|parser PARSER] [-w|writer WRITER]  NODE -f PERLFILE FILE</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>parsers an input file using the specified parser (which may be a built
in stag parser, such as xml) and filters the resulting stag tree
according to a user-supplied subroutine, writing out only the
nodes/elements that pass the test.</p>
<p>the parser is event based, so it should be able to handle large files
(although if the node you parse is large, it will take up more memory)</p>
<p>
</p>
<hr />
<h1><a name="arguments">ARGUMENTS</a></h1>
<dl>
<dt><strong><a name="item_%2dp%7cparser_format">-p|parser FORMAT</a></strong><br />
</dt>
<dd>
FORMAT is one of xml, sxpr or itext, or the name of a perl module
</dd>
<dd>
<p>xml assumed as default</p>
</dd>
<p></p>
<dt><strong><a name="item_%2dw%7cwriter_format">-w|writer FORMAT</a></strong><br />
</dt>
<dd>
FORMAT is one of xml, sxpr or itext, or the name of a perl module
</dd>
<p></p>
<dt><strong><a name="item_%2dc%7ccount">-c|count</a></strong><br />
</dt>
<dd>
prints the number of nodes that pass the test
</dd>
<p></p>
<dt><strong><a name="item_%2dfilterfile%7cf">-filterfile|f</a></strong><br />
</dt>
<dd>
a file containing a perl subroutine (in place of the SUB argument)
</dd>
<p></p>
<dt><strong><a name="item_%2dq%7cquery_tag1%3dval1_%2dq%7cquery_tag2%3dval2_">-q|query TAG1=VAL1 -q|query TAG2=VAL2 ...  -q|query TAGN=VALN</a></strong><br />
</dt>
<dd>
filters based on the field TAG
</dd>
<dd>
<p>other operators can be used too - eg &lt;, &lt;=, etc</p>
</dd>
<dd>
<p>multiple q arguments can be passed in</p>
</dd>
<dd>
<p>for more complex operations, pass in your own subroutine, see below</p>
</dd>
<p></p>
<dt><strong><a name="item_sub">SUB</a></strong><br />
</dt>
<dd>
a perl subroutine. this subroutine is evaluated evry time NODE is
encountered - the stag object for NODE is passed into the subroutine.
</dd>
<dd>
<p>if the subroutine passes, the node will be passed to the writer for
display</p>
</dd>
<p></p>
<dt><strong><a name="item_node">NODE</a></strong><br />
</dt>
<dd>
the name of the node/element we are filtering on
</dd>
<p></p>
<dt><strong><a name="item_file">FILE</a></strong><br />
</dt>
<dd>
the file to be parser. If no parser option is supplied, this is
assumed to a be a stag compatible syntax (xml, sxpr or itext);
otherwise you should parse in a parser name or a parser module that
throws stag events
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><a href="./Data/Stag.html">the Data::Stag manpage</a></p>

</body>

</html>
